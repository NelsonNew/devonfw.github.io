{"type":"doc","filename":"devonfw-guide_devon4ng.wiki_guide-ngrx-simple-store.asciidoc.html","anchor":"devonfw-guide_devon4ng.wiki_guide-ngrx-simple-store.asciidoc_creating-a-simple-store","title":"Creating a Simple Store","breadcrumbs":["Angular","NgRx","State, Selection and Reducers"],"text":"Creating a Simple Store\n\nIn the following pages we use the example of an online streaming service. We will model a particular feature, a watchlist that can be populated by the user with movies she or he wants to see in the future.\n\n\nInitializing NgRx\n\nIf you’re starting fresh, you first have to initialize NgRx and create a root state. The fastest way to do this is using the schematic:\n\n\n\n\n\n\n\nThis will automatically generate a root store and register it in the app module. Next we generate a feature module for the watchlist:\n\n\n` ng generate module watchlist`\n\n\nand create a corresponding feature store:\n\n\n` ng generate store watchlist/Watchlist -m watchlist.module.ts`\n\n\nThis generates a file watchlist/reducers/index.ts with the reducer function, and registers the store in the watchlist module declaration.\n\n\n\n\n\nWarning\n\n\n\nIf you’re getting an error Schematic \"store\" not found in collection \"@schematics/angular\", this means you forgot to register the NgRx schematics as default.\n\n\n\n\n\n\nNext, add the WatchlistModule to the AppModule imports so the feature store is registered when the application starts. We also added the store devtools which we will use later, resulting in the following file:\n\n\napp.module.ts\n\n\n\n\n\n\n\n\nCreate an entity model and initial state\n\nWe need a simple model for our list of movies. Create a file watchlist/models/movies.ts and insert the following code:\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWe discourage putting several types into the same file and do this only for the sake of keeping this tutorial brief.\n\n\n\n\n\n\nLater we will learn how to retrieve data from the back-end using effects. For now we will create an initial state for the user with a default movie.\n\n\nState is defined and transforms by a reducer function. Let’s create a watchlist reducer:\n\n\n\n\n\n\n\nOpen the generated file watchlist-data.reducer.ts. You see three exports: The State interface defines the shape of the state. There is only one instance of a feature state in the store at all times. The initialState constant is the state at application creation time. The reducer function will later be called by the store to produce the next state instance based on the current state and an action object.\n\n\nLet’s put a movie into the user’s watchlist:\n\n\nwatchlist-data.reducer.ts\n\n\n\n\n\n\n\n\nSelect the current watchlist\n\nState slices can be retrieved from the store using selectors.\n\n\nCreate a watchlist component:\n\n\n\n\n\n\n\nand add it to the exports of WatchlistModule. Also, replace app.component.html with\n\n\n\n\n\n\n\nState observables are obtained using selectors. They are memoized by default, meaning that you don’t have to worry about performance if you use complicated calculations when deriving state — these are only performed once per state emission.\n\n\nAdd a selector to watchlist-data.reducer.ts:\n\n\n\n\n\n\n\nNext, we have to re-export the selector for this sub-state in the feature reducer. Modify the watchlist/reducers/index.ts like this:\n\n\nwatchlist/reducers/index.ts\n\n\n\n\n\n\n\n\n\nThe feature state, each member is managed by a different reducer\n\n\nFeature states are registered by the forFeature method. This interface provides a typesafe path from root to feature state.\n\n\nTie sub-states of a feature state to the corresponding reducers\n\n\nCreate a selector to access the 'watchlist' feature state\n\n\nselect the watchlistData sub state\n\n\nre-export the selector\n\n\n\n\nNote how createSelector allows to chain selectors. This is a powerful tool that also allows for selecting from multiple states.\n\n\nYou can use selectors as pipeable operators:\n\n\nwatchlist.component.ts\n\n\n\n\n\n\n\nwatchlist.component.html\n\n\n\n\n\n\n\n\nDispatching an action to update watched minutes\n\nWe track the user’s current progress at watching a movie as the playbackMinutes property. After closing a video, the watched minutes have to be updated. In NgRx, state is being updated by dispatching actions. An action is an option with a (globally unique) type discriminator and an optional payload.\n\n\nCreating the action\n\nCreate a file playback/actions/index.ts. In this example, we do not further separate the actions per sub state. Actions can be defined by using action creators:\n\n\nplayback/actions/index.ts\n\n\n\n\n\n\n\nFirst we specify the type, followed by a call to the payload definition function. Next, we create a union of all possible actions for this file using union, which allows us a to access action payloads in the reducer in a typesafe way.\n\n\n\n\n\nTip\n\n\n\nAction types should follow the naming convention [Source] Event, e.g. [Recommended List] Hide Recommendation or [Auth API] Login Success. Think of actions rather as events than commands. You should never use the same action at two different places (you can still handle multiple actions the same way). This facilitate tracing the source of an action. For details see Good Action Hygiene with NgRx by Mike Ryan (video).\n\n\n\n\n\n\n\nDispatch\n\nWe skip the implementation of an actual video playback page and simulate watching a movie in 10 minute segments by adding a link in the template:\n\n\nwatchlist-component.html\n\n\n\n\n\n\n\nwatchlist-component.ts\n\n\n\n\n\n\n\n\nState reduction\n\nNext, we handle the action inside the watchlistData reducer. Note that actions can be handled by multiple reducers and effects at the same time to update different states, for example if we’d like to show a rating modal after playback has finished.\n\n\nwatchlist-data.reducer.ts\n\n\n\n\n\n\n\nNote how we changed the reducer’s function signature to reference the actions union. The switch-case handles all incoming actions to produce the next state. The default case handles all actions a reducer is not interested in by returning the state unchanged. Then we find the watchlist item corresponding to the movie with the given id and update the playback minutes. Since state is immutable, we have to clone all objects down to the one we would like to change using the object spread operator (…​).\n\n\n\n\n\nCaution\n\n\n\nSelectors rely on object identity to decide whether the value has to be recalculated. Do not clone objects that are not on the path to the change you want to make. This is why updatePlaybackMinutesMapper returns the same item if the movie id does not match.\n\n\n\n\n\n\n\nAlternative state mapping with Immer\n\nIt can be hard to think in immutable changes, especially if your team has a strong background in imperative programming. In this case, you may find the Immer library convenient, which allows to produce immutable objects by manipulating a proxied draft. The same reducer can then be written as:\n\n\nwatchlist-data.reducer.ts with Immer\n\n\n\n\n\n\n\nImmer works out of the box with plain objects and arrays.\n\n\n\nRedux devtools\n\nIf the StoreDevToolsModule is instrumented as described above, you can use the browser extension Redux devtools to see all dispatched actions and the resulting state diff, as well as the current state, and even travel back in time by undoing actions.\n\n\n\n\n\nFigure 68. Redux devtools\n\n\nContinue with learning about effects\n\n\n\n\n\n\n\n"}