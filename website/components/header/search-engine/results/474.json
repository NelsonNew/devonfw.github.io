{"type":"doc","filename":"devonfw-guide_devon4ng.wiki_meta-architecture.asciidoc.html","anchor":"devonfw-guide_devon4ng.wiki_meta-architecture.asciidoc_devonfw-reference-client-architecture","title":"devonfw Reference Client Architecture","breadcrumbs":["Angular","Architecture","Meta Architecture"],"text":"devonfw Reference Client Architecture\n\nThe following gives a complete overview of the proposed reference architecture. It will be built up incrementally in the following sections.\n\n\n\n\n\n\n\nFigure 1 Overview\n\n\nClient Architecture\n\nOn the highest level of abstraction we see the need to differentiate between dialog components and their container they are managed in, as well as the access to the application server being the back-end for the client (e.g. an devon4j instance). This section gives a summary of these components and how they relate to each other. Detailed architectures for each component will be supplied in subsequent sections\n\n\n\n\n\n\n\nFigure 2 Overview of Client Architecture\n\n\nDialog Component\n\nA dialog component is a logical, self-contained part of the user interface. It accepts user input and actions and controls communication with the user. Dialog components use the services provided by the dialog container in order to execute the business logic. They are self-contained, i.e. they possess their own user interface together with the associated logic, data and states.\n\n\n\n\nDialog components can be composed of other dialog components forming a hierarchy\n\n\nDialog components can interact with each other. This includes communication of a parent to its children, but also between components independent of each other regarding the hierarchy.\n\n\n\n\n\nDialog Container\n\nDialog components need to be managed in their life-cycle and how they can be coupled to each other. The dialog container is responsible for this along with the following:\n\n\n\n\nBootstrapping the client application and environment\n\n\n\nConfiguration of the client\n\n\nInitialization of the application server access component\n\n\n\n\n\nDialog Component Management\n\n\n\nControlling the life-cycle\n\n\nControlling the dialog flow\n\n\nProviding means of interaction between the dialogs\n\n\nProviding application server access\n\n\nProviding services to the dialog components\n(e.g. printing, caching, data storage)\n\n\n\n\n\nShutdown of the application\n\n\n\n\n\nApplication Server Access\n\nDialogs will require a back-end application server in order to execute their business logic. Typically in an devonfw application the service layer will provide interfaces for the functionality exposed to the client. These business oriented interfaces should also be present on the client backed by a proxy handling the concrete call of the server over the network. This component provides the set of interfaces as well as the proxy.\n\n\n\n\nDialog Container Architecture\n\nThe dialog container can be further structured into the following components with their respective tasks described in own sections:\n\n\n\n\n\n\n\nFigure 3 Dialog Container Architecture\n\n\nApplication\n\nThe application component represents the overall client in our architecture. It is responsible for bootstrapping all other components and connecting them with each other. As such it initializes the components below and provides an environment for them to work in.\n\n\n\nConfiguration Management\n\nThe configuration management manages the configuration of the client, so the client can be deployed in different environments. This includes configuration of the concrete application server to be called or any other environment-specific property.\n\n\n\nDialog Management\n\nThe Dialog Management component provides the means to define, create and destroy dialog components. It therefore offers basic life-cycle capabilities for a component. In addition it also allows composition of dialog components in a hierarchy. The life-cycle is then managed along the hierarchy, meaning when creating/destroying a parent dialog, this affects all child components, which are created/destroyed as well.\n\n\n\nService Registry\n\nApart from dialog components, a client application also consists of services offered to these. A service can thereby encompass among others:\n\n\n\n\nAccess to the application server\n\n\nAccess to the dialog container functions for managing dialogs or accessing the configuration\n\n\nDialog independent client functionality such as Printing, Caching, Logging, Encapsulated business logic such as tax calculation\n\n\nDialog component interaction\n\n\n\n\nThe service registry offers the possibility to define, register and lookup these services. Note that these services could be dependent on the dialog hierarchy, meaning different child instances could obtain different instances / implementations of a service via the service registry, depending on which service implementations are registered by the parents.\n\n\nServices should be defined as interfaces allowing for different implementations and thus loose coupling.\n\n\n\n\nDialog Component Architecture\n\nA dialog component has to support all or a subset of the following tasks:\n(T1)\tDisplaying the user interface incl. internationalization\n(T2)\tDisplaying business data incl. changes made to the data due to user interactions and localization of the data\n(T3)\tAccepting user input including possible conversion from e.g. entered Text to an Integer\n(T4)\tDisplaying the dialog state\n(T5)\tValidation of user input\n(T6)\tManaging the business data incl. business logic altering it due to user interactions\n(T7)\tExecution of user interactions\n(T8)\tManaging the state of the dialog (e.g. Edit vs. View)\n(T9)\tCalling the application server in the course of user interactions\n\n\nFollowing the principle of separation of concerns, we further structure a dialog component in an own architecture allowing us the distribute responsibility for these tasks along the defined components:\n\n\n\n\n\n\n\nFigure 4 Overview of dialog component architecture\n\n\nPresentation Layer\n\nThe presentation layer generates and displays the user interface, accepts user input and user actions and binds these to the dialog core layer (T1-5). The tasks of the presentation layer fall into two categories:\n\n\n\n\nProvision of the visual representation (View component)\nThe presentation layer generates and displays the user interface and accepts user input and user actions. The logical processing of the data, actions and states is performed in the dialog core layer. The data and user interface are displayed in localized and internationalized form.\n\n\nBinding of the visual representation to the dialog core layer\nThe presentation layer itself does not contain any dialog logic. The data or actions entered by the user are then processed in the dialog core layer. There are three aspects to the binding to the dialog core layer. We refer to “data binding”, “state binding” and “action binding”. Syntactical and (to a certain extent) semantic validations are performed during data binding (e.g. cross-field plausibility checks). Furthermore, the formatted, localized data in the presentation layer is converted into the presentation-independent, neutral data in the dialog core layer (parsing) and vice versa (formatting).\n\n\n\n\n\nDialog Core Layer\n\nThe dialog core layer contains the business logic, the control logic, and the logical state of the dialog. It therefore covers tasks T5-9:\n\n\n\n\nMaintenance of the logical dialog state and the logical data\nThe dialog core layer maintains the logical dialog state and the logical data in a form which is independent of the presentation. The states of the presentation (e.g. individual widgets) must not be maintained in the dialog core layer, e.g. the view state could lead to multiple presentation states disabling all editable widgets on the view.\n\n\nImplementation of the dialog and dialog control logic\nThe component parts in the dialog core layer implement the client specific business logic and the dialog control logic. This includes, for example, the manipulation of dialog data and dialog states as well as the opening and closing of dialogs.\n\n\nCommunication with the application server\nThe dialog core layer calls the interfaces of the application server via the application server access component services.\n\n\n\n\nThe dialog core layer should not depend on the presentation layer enforcing a strict layering and thus minimizing dependencies.\n\n\n\nInteractions between dialog components\n\nDialog components can interact in the following ways:\n\n\n\n\n\n\n\n\n\nEmbedding of dialog components\nAs already said dialog components can be hierarchically composed. This composition works by embedding on dialog component within the other. Apart from the life-cycle managed by the dialog container, the embedding needs to cope for the visual embedding of the presentation and core layer.\n\n\n\nEmbedding dialog presentation\nThe parent dialog needs to either integrate the embedded dialog in its layout or open it in an own model window.\n\n\nEmbedding dialog core\nThe parent dialog needs to be able to access the embedded instance of its children. This allows initializing and changing their data and states. On the other hand the children might require context information offered by the parent dialog by registering services in the hierarchical service registry.\n\n\n\n\n\nDialog flow\nApart from the embedding of dialog components representing a tight coupling, dialogs can interact with each other by passing the control of the UI, i.e. switching from one dialog to another.\n\n\n\n\nWhen interacting, dialog components should interact only between the same or lower layers, i.e. the dialog core should not access the presentation layer of another dialog component.\n\n\n\n\n\n"}