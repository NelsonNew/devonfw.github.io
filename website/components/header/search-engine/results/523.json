{"type":"doc","filename":"devonfw-guide_devon4node.wiki_layer-controller.asciidoc.html","anchor":"devonfw-guide_devon4node.wiki_layer-controller.asciidoc_how-to-implement-the-controller-layer","title":"How to implement the controller layer","breadcrumbs":["NodeJS","Layers","Controller Layer"],"text":"How to implement the controller layer\n\nThis layer is implemented by the NestJS controllers. Let’s see how it works with an example:\n\n\n\n\n\n\n\nAs you can see in the example, to create a controller you only need to decorate a class with the Controller decorator. This example is handling all request to coffee/coffees.\n\n\nAlso, you have defined one handler. This handler is listening to POST request for the route coffee/coffees/search. In addition, this handler is waiting for a CoffeeSearch object and returns an array of Coffee. In order to keep it simple, that’s all that you need in order to define one route.\n\n\nOne important thing that can be observed in this example is that there is no business logic. It delegates to the service layer and return the response to the client. At this point, transformations from the value that you receive from the service layer to the desired return type are also allowed.\n\n\nBy default, every POST handler return an HTTP 204 response with the returned value as body, but you can change it in a easy way by using decorators. As you can see in the example, the handler will return a HTTP 200 response (@HttpCode(200)).\n\n\nFinally, if the service layer throws an error, this handler will catch it and return a HTTP 400 Bad Request response. The controller layer is the only one that knows about the answers to the client, therefore it is the only one that knows which error codes should be sent.\n\n\n\n"}