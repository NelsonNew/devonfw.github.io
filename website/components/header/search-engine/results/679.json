{"type":"doc","filename":"devonfw-guide_ide.wiki_LICENSE.asciidoc.html","anchor":"devonfw-guide_devon4j.wiki_quarkus.asciidoc","title":"Quarkus","breadcrumbs":["devonfw-ide","Support","License"],"text":"Quarkus\n\nQuarkus is a Java framework for building cloud-native apps.\nIt is fully supported by devonfw as an option and alternative to spring.\nAdditional things like extensions will be available on the  devon4quarkus GitHub repository.\n\n\nGuide to the Reader\n\nDepending on your intention of reading this document, you might be more interested in the following chapters:\n\n\n\n\nIf you are completely new to Quarkus, you may be interested in the pros and cons of Quarkus. Also, take a look at the official Quarkus website. You might also be interested in the features that GraalVM offers.\n\n\nIf you are new to devon4j, take a look at devon4j’s recommendations on general best practices. Check out the chapters on architecture design, project structuring, and coding conventions. Follow the referenced links to explore a topic in more depth.\n\n\nIf you are an experienced Spring developer and want to get in touch with Quarkus, read our Getting started with Quarkus for Spring developers guide.\n\n\nIf you’re looking to build your first Quarkus application, the Quarkus website offers some good getting started guides. Also, check out our Quarkus template guide, which gives you some recommendations on extensions and frameworks to use. It also provides some links to the Quarkus code generator with preselected configurations you can use to create your application.\n\n\nIf you want to have a Quarkus sample application using devon4j recommendations, check out our Quarkus reference application.\n\n\nIf you have a Spring application and want to migrate it to Quarkus, take a look at our migration guide.\n\n\nIf you already have some experience with devon4j and Quarkus and need more information on a specific topic, check out our Quarkus guides. If you don’t find what you are looking for there, check out the general section. devon4j uses general solutions for Java, so solutions for both Quarkus and Spring are documented there.\n\n\nIf you want to learn how to build native images, check out this guide.\n\n\n\n\n\nPros\n\nQuarkus offers the following benefits:\n\n\n\n\nfast turn-around cycles for developers\nSave changes in your Java code and immediately test the results without restarting or waiting\n\n\nfaster start-up and less memory footprint\nWhen building your app as native-images via GraalVM, it gets highly optimized. As a result, it starts up lightning fast and consumes much less memory. This is a great advantage for cloud deployment as well as for sustainability. You can find a performance comparison between Spring and Quarkus here.\n\n\nclean and lean\nAs quarkus was born as a cloud-native framework, it is very light-weight and does not carry much history and legacy.\n\n\n\n\n\nCons\n\nQuarkus has the following drawbacks:\n\n\n\n\nless flexible\nQuarkus is less flexible compared to spring, or in other words, it is more biased and coupled to specific implementations. However, the implementations  work and you have less things to choose and worry about. However, in case you want to integrate a specific or custom library, you may hit limitations or lose support for native-images, especially when that library is based on reflection. Therefore, check your requirements and technology stack early on when making your choice.\n\n\nless established\nSince quarkus was born in 2019, it is modern but also less established. It will be easier to get developers for spring, but we already consider quarkus mature and established enough for building production-ready apps.\n\n\n\n\n\nQuarkus Quickstart\n\nThis guide serves as a quickstart on how to create a Quarkus app, briefly presenting the key functionalities that Quarkus provides, both for beginners and experienced developers.\n\n\nIntroduction to Quarkus\n\nTo get a first introduction to Quarkus, you can read the Quarkus introduction guide. To get a brief overview of where you can find the important Quarkus related guides, follow the chapter guide to the reader.\nAlso, see the comparison of the advantages and disadvantages of a Quarkus application compared to the alternative framework Spring.\nThis comparison will be supported by our performance comparison between Spring and Quarkus, which demonstrates the lower resource consumption and startup time of Quarkus applications.\n\n\n\nInstallation of Tools and Dependencies\n\nFirst, we need to install some dependencies and tools before we can start programming. Our tool devonfw-ide comes with many development tools for you.\nWe need to install the following tools for this guide:\n\n\n\n\nMaven\n\n\nJava\n\n\nany IDE (devonfw-ide supports Eclipse, Intellij and VScode)\n\n\nDocker\n\n\n\n\nWe recommend installing the devonfw-ide with the tools, but if you already have your system configured and the tools above installed, you can skip to Bootstrap a Quarkus Project, otherwise we will show you how to set up and update your devonfw-ide.\n\n\ndevonfw-ide\n\n\nInstall devonfw-ide\nFollow the Setup to install the devonfw-ide with Java, Maven, Eclipse and VScode.\n\n\n\nCommand to install Docker\ndevon docker setup\n\n\n\n\n\nUpdate devonfw-ide\nAs we are still working on improving devonfw-ide, we recommend to update your already installed devonfw-ide and tools in order to include essential features for cloud development with Quarkus that you could be missing.\n\n\n\n\nUse the commands devon ide update, devon ide update software, and devon ide scripts to update devonfw-ide and all installed software.\n\n\nGo to the main folder under workspaces of the devonfw-ide installation.\nWe will create the project there.\n\n\n\nBootstrap a Quarkus Project\n\nQuarkus provides multiple ways to bootstrap a project.\nThe option to bootstrap a project via the command-line is shown in the Quarkus getting started guide Bootstrap the project.\nQuarkus also provides a project builder where you can select some extensions, the build tool for your project, and if you want, some starter code.\nThis will deliver a project skeleton with the configured project dependencies and also contributes the information to compile the application natively. To get some recommendations on starter templates, follow the guide on: template recommendations.\n\n\n\n\n\n\n\n\n\nBy creating a Quarkus project from the command-line or with the project builder, you get a different project structure and have to adapt it to the devon4j conventions shown in the next Chapter.\n\n\n\n\n\n\nProject Structure\n\nWe provide a recommendation and guideline for a modern project structure to help organize your project into logically related modules.\nIn order to comply with the requirements of modern cloud development and microservice architectures, follow the guide and apply the modern project structure to your project. You can also find similar modules in our example projects.\n\n\n\n\nIntroduction to Quarkus Functionality\n\nBefore we start programming, you should first have a look at the functionality of Quarkus.\n\n\nQuarkus functionality guides\n\n\nGetting started guide from Quarkus\nThis guide presents a good overview of the functionality of Quarkus. The simple Greeting Service gives a brief introduction into concepts like CDI, testing, dev mode, packaging, and running the app.\n\n\nFrom Spring to Quarkus\nFor experienced Spring developers that have already followed devon4j guidelines, you can read our guide to getting started with Quarkus for Spring developer, as it goes more into the differences that can give you a more detailed comparison to Spring.\n\n\n\nMigrate a Spring app to Quarkus\nThis guide shows how to migrate a Spring application to a Quarkus application with devon4j conventions.\n\n\n\n\n\n\n\n\nCreate a REST service\n\nNow let’s create our first REST CRUD service with Quarkus.\nWe give you the options of using a guide to start to code the service yourself or to just download a service that’s ready to use.\n\n\nOptions\n\n\nCreate the service yourself\nThere is a good Quarkus guide for a simple JSON REST service that will guide you through your first application and help you with implement the definition of endpoints with JAX-RS and an Entity that will be managed by the service, and also how to configure the JSON support.\n\n\nUse an existing Quarkus project\nYou don’t want to code a service and just want to test some Quarkus functionalities? Just load a Quarkus sample project provided for every existing quickstart guide and the supported framework.\nOur Team also provides some Quarkus applications that are working and can be loaded and tested.\n\n\n\nreference project is a service that manages products. It contains the devon4j modern project structure, pagination, queries, a Postgres database, SwaggerUI, and support for Kubernetes deploy. To add OpenTelemetry support, see the following guide.\nThis project will be steadily improved and is used to showcase the abilities of Quarkus with devon4j.\n\n\nminimal Quarkus project is just the Quarkus project from a getting started with Quarkus guide with a Greeting Services modified with the correct modern structure mentioned in the chapter Project Structure\n\n\n\n\n\n\n\n\nOpenAPI generation\n\nWe provide a guide with a short introduction to the OpenAPI specification with two plugins that are important in a Quarkus Context.\n\n\n\n\nSmallrye Openapi supported by quarkus\n\n\nservicedocgen Maven Plugin.\n\n\n\n\nA more detailed usage guide to the Smallrye Plugin is provided by Quarkus OpenAPI and Swagger guide.\n\n\n\nHow to Integrate a Database\n\nThe next step for our REST service would be to integrate a database to store the objects of the entity.\n\n\nWith Quarkus, adding a database can be easy, because Quarkus can take over the build-up and connection process.\nFirst, you should understand our guides on the concepts of working with data. Then, we will show how to integrate a database with Quarkus.\n\n\nData Principles Guides\n\n\nGeneral devon4j JPA guide\nTo get an insight into the general JPA usage, read the JPA guide containing a general explanation of the Java Persistence API.\n\n\nDifference to SpringData\nIf you have already worked with SpringData, this is also partially supported with Quarkus. This is explained in more detail in this SpringData Guide.\n\n\n\n\nDatabase Integration\n\n\nQuarkus zero config dev mode\nStarting with the database implementation in Quarkus, we recommend for beginners to use the DEV mode Zero Config Setup (Dev Services). This is especially great for testing the code without a database set up.\nQuarkus does all the work for you and configures a database and creates the database and tables (schemas) for you.\n\n\n\nConfiguration Properties\nA list of all database configuration properties for the Dev services\n\n\n\n\n\nIntegrate a simple Hibernate ORM database\nThe zero config setup only works with the Dev mode, it’s comfortable in the first phases of the creation of your service but if the goal is to also get a deployable version, you have to create your own database and integrate it.\nThis Quarkus guide shows, how to integrate a Hibernate ORM database with an example service.\n\n\n\nConfiguration list for JDBC\nA list of all configuration that is possible with a JDBC configuration properties\n\n\n\n\n\nReactive CRUD application with Panache\nQuarkus unifies reactive and imperative programming.\nReactive is an architectural principle to build robust, efficient, and concurrent applications.\nFor an introduction into reactive and how Quarkus enables it, follow this Quarkus reactive architecture article and also the reactive quickstart.\nTo get started with reactive and implement reactive methods, you can follow the Quarkus reactive guide.\nThe reactive guide uses the Quarkus based implementation of a Hibernate ORM called Panache.\nThe implementation is not our first choice with devon4j and therefore not part of our recommendations, but to understand the reactive guide you can read the Hibernate ORM with Panache guide first to prevent possible problems following the guide.\n\n\n\n\n\n\n\n\n\n\n\nYou need an installed Docker version for the zero config setup.\n\n\n\n\n\n\nDatabase Migration\nFor schema-based databases, we recommend migrating databases with Flyway.\nIn that case, our general migration guide can give you an overview if you are not familiar with migration.\n.. Flyway guide for Quarkus\nThis Quarkus guide will show how to work with the Flyway extension in a Quarkus application.\nThis should be used if you start your own database and do not leave the creation to quarkus.\n\n\n\nTesting a Quarkus Application\n\nAfter we have built the service, we have to verify it with some tests.\nWe will give you some guidelines to implement some test cases.\n\n\nTesting Guides\n\n\nGeneral testing guide\nFor users that aren’t familiar with the devon4j testing principles, we created a general best practices and recommendations guide for testing.\n\n\n\nOur guide for testing with Quarkus\nIn addition, we also provide a guide that specifically addresses the testing of a Quarkus application.\n\n\n\n\n\n\n\nMost of the Quarkus applications are already equipped with a basic test and our reference project provides some further test cases. If you want to improve and extend the tests, you can also follow the large Quarkus guide for testing.\n\n\n\nPackaging of a Quarkus application and creation of a native executable\n\nQuarkus applications can be packaged into different file types. The following link will show you how to build them and give you a short explanation of the characteristics of these files.\n\n\nPackage types\n\n\nfast-jar\n\n\nmutable-jar\n\n\nuber-jar\n\n\nnative executable\n\n\n\n\nTo package an application, use the command mvn package and Quarkus will generate the output in the /target folder. For the native executables, the command needs more parameters, which is explained in the link above.\n\n\nConfigure the Output with these configuration properties\n\n\n\nCreate and build a Docker Image\n\nQuarkus supports Jib, S2I and Docker for building images. We focus on building a Quarkus App with Docker.\nYou get a generated Dockerfile from Quarkus in the src/main/docker folder of any project generated from Quarkus. There are multiple Dockerfiles.\n\n\nDockerfiles\n\n\nDockerfile.jvm\nDockerfile for Quarkus application in the JVM mode. running in Red Hat Universal Base Image 8 Minimal Container\n\n\nDockerfile.legacy-jar\nDockerFile for Quarkus application in JVM mode with the legacy jar running in Red Hat Universal Base Image 8 Minimal Container.\n\n\nDockerfile.native\nDockerfile using the native executable running in Red Hat Universal Base Image 8 Minimal container.\n\n\nDockerfile.native-distroless\nThe native file will run in a Distroless container. Distroless images are very small containers with just the application and runtime dependencies and without the other programs that come with a Linux distribution.\n\n\n\n\n\n\nFor more information to the different executables go back to the chapter Packaging of a Quarkus application and creation of a native executable\n\n\n\n\nTo simply build and run a Docker image, you can follow the instructions Quarkus provides for every Dockerfile in the comments block.\n\n\nDocker commands example for the JVM Dockerfile from our reference project\n\n\n\n\n\n\n\nQuarkus is also able to build the image while packaging the application, so you don’t have to execute the command from above.\nTo perform Docker builds with the generated Dockerfiles from above, you need to add the following extension to your project with the command mvn quarkus:add-extension -Dextensions=\"container-image-docker\".\n\n\nYou also have to set the quarkus.container-image.build=true. You can add this to your application.properties or just append it to the packaging command like this: ./mvn package -Dquarkus.container-image.build=true.\n\n\nIf your needs exceed the instructions given by the file, we recommend to follow the Docker getting started guide to get familiar with Docker and customize the Dockerfiles according to your needs.\nTo specify your container build, you can use the general container image configurations properties and the Docker image configurations properties when building and runnig Docker images.\n\n\n\n\n\nMigrate from Spring to Quarkus\n\nThis guide will cover the migration process of a Spring application to a Quarkus application. There are already articles about migrating from Spring to Quarkus (e.g. https://developers.redhat.com/blog/2020/04/10/migrating-a-spring-boot-microservices-application-to-quarkus, https://dzone.com/articles/migrating-a-spring-boot-application-to-quarkus-cha).\nThis guide will focus more on the devon4j specific aspects. We assume that a working Spring application exists, built in the classic devon4j specific way (e.g. Jump The Queue or My Thai Star).\n\n\nCreate the Quarkus application\n\nWe start with an empty Quarkus project. You can create the project with Maven on the command line or use the online generator. The advantage of the online generator is that you have a pre-selection of dependencies to use in your project.\nFor starters, let’s select the basic dependencies required to develop a REST service with database connectivity (you can use one of the links in the Quarkus template guide): RESTEasy JAX-RS, RESTEasy Jackson, Hibernate ORM, Spring Data JPA API, JDBC Driver (choose the type of database you need), Flyway (if you have database migration schemas), SmallRye Health (optional for Health Monitoring)\n\n\nThe list does not include all required dependencies. We will add more dependencies to the project later. For now, generate the application with these dependencies.\n\n\nMigration Toolkit from Red Hat\n\nRed Hat provides a migration toolkit (MTA, Migration Toolkit for Applications), that supports migration of a Spring to a Quarkus application. There are several versions of this toolkit (e.g., a web console, a Maven plugin, or an IDE plugin).\nThe MTA analyzes your existing application and generates a report with hints and instructions for migrating from Spring to Quarkus. For example, it gives you an indication of which dependencies are not supported in your project for a Quarkus application and which dependencies you need to swap them with. The analysis is rule-based, and you can also add your own rules that will be checked during analysis.\n\n\n\n\nEntities\n\nThere is nothing special to consider when creating the entities. In most cases, you can simply take the code from your Spring application and use it for your Quarkus application. Usually, the entities extend a superclass ApplicationPersistenceEntity containing, for example, the id property. You can also take this class from your Spring application and reuse it.\n\n\n\nTransfer objects\n\nThe next step is to create the appropriate transfer objects for the entities. In a devon4j Spring application, we would use CobiGen to create these classes. Since CobiGen is not usable for this purpose in Quarkus applications yet, we have to create the classes manually.\n\n\nFirst, we create some abstract base classes for the search criteria and DTO classes. Normally, these would also be created by CobiGen.\n\n\nListing 10. AbstractSearchCriteriaTo\n\n\n\n\n\nListing 11. AbstractDto\n\n\n\n\n\nThe class AbstractTo, extended by other classes, would be provided by the devon4j-basic module in a devon4j Spring application. You can take the code from here and reuse it in your Quarkus project.\n\n\nNow you can create your transfer objects. Most of the code of the transfer objects of your Spring application should be reusable. For Quarkus, we recommend (as mentioned here) to use *Dto instead of *Eto classes. Be sure to change the names of the classes accordingly.\n\n\n\nData Access Layer\n\nIn devon4j, we propose to use Spring Data JPA to build the data access layer using repositories and Querydsl to build dynamic queries. We will also use this approach for Quarkus applications, but we need to change the implementation because the devon4j modules are based on reflection, which is not suitable for Quarkus.\nIn Quarkus we will use Querydsl using code generation. So for this layer, more changes are required and we can’t just take the existing code.\n\n\nFirst, create a repository interface for your entity class that extends JpaRepository (see here).\n\n\nTo add QueryDSL support to your project, add the following dependencies to your pom.xml file:\n\n\nListing 12. pom.xml\n\n\n\n\n\nAs mentioned above, we will use QueryDSL with code generation. For this, add the QueryDSL annotation processor to your plugins:\n\n\nListing 13. pom.xml\n\n\n\n\n\nTo implement the queries, follow the corresponding guide.\n\n\nSet the following properties in the application.properties file to configure the connection to your database (see also here):\n\n\n\n\n\n\n\n\nLogic Layer\n\nFor the logic layer, devon4j uses a use-case approach. You can reuse the use case interfaces from the api module of the Spring application. Again, make sure to rename the transfer objects.\n\n\nCreate the appropriate class that implements the interface. Follow the implementation section of the use-case guide to implement the methods. For mapping the entities to the corresponding transfer objects, see the next section.\n\n\n\nMapping\n\nFor bean mapping, we need to use a completely different approach in the Quarkus application than in the Spring application. For Quarkus, we use MapStruct, which creates the mapper at build time rather than at runtime using reflection. Add the following dependencies to your pom.xml.\n\n\nListing 14. pom.xml\n\n\n\n\n\nThen you can create the mapper as follows:\n\n\nListing 15. Mapper\n\n\n\n\n\nInject the mapper into your use-case implementation and simply use the methods. The method implementations of the mapper are created when the application is built.\n\n\n\nService Layer\n\nFor the implementation of the service layer, we use the JAX-RS for both Quarkus and Spring applications to create the REST services. Classic devon4j Spring applications rely on Apache CFX as the implemention of JAX-RS.\nFor Quarkus, we use RESTEasy. Since both are implementations of JAX-RS, much of the Spring application code can be reused.\n\n\nTake the definition of the REST endpoints from the api module of the Spring application (make sure to rename the transfer objects), inject the use-cases from the logic layer and use them in the REST service methods as follows:\n\n\nListing 16. REST service\n\n\n\n\n\n\nSummary\n\nAs you have seen, some parts hardly differ when migrating a Spring application to a Quarkus application, while other parts differ more. The above sections describe the parts needed for simple applications that provide REST services with a data access layer.\nIf you add more functionality, more customization and other frameworks, dependencies may be required. If that is the case, take a look at the corresponding guide on the topic in the devon4j documentation or check if there is a tutorial on the official Quarkus website.\n\n\nFurthermore, we can summarize that migrating from a Spring application to a Quarkus representative is not complex. Although Quarkus is a very young framework (release 1.0 was in 2019), it brings a lot of proven standards and libraries that you can integrate into your application.\nThis makes it easy to migrate and reuse code from existing (Spring) applications. Also, Quarkus comes with Spring API compatibility for many Spring modules (Spring Data JPA, Spring DI, etc.), which makes it easier for developers to reuse their knowledge.\n\n\n\n\n\nSpring Native vs Quarkus\n\nNowadays, it is very common to write an application and deploy it to a cloud.\nServerless computing and Function-as-a-Service (FaaS) have become\nvery popular.\nWhile many challenges arise when deploying a Java application into the latest cloud environment, the biggest challenges facing developers are memory footprint and the startup time required\nfor the Java application, as more of these keeps the host’s costs high in public clouds and Kubernetes clusters. With the introduction of frameworks like micronaut and microprofile, Java processes are getting faster and more lightweight. In a similar context, Spring has introduced\nSpring Native which aims to solve the big memory footprint of Spring and its slow startup time to potentially rival the new framework called Quarkus, by Red Hat. This document briefly discusses both of these two frameworks and their potential suitability with devonfw.\n\n\nQuarkus\n\nQuarkus is a full-stack, Kubernetes-native Java framework made for JVMs. With its container-first-philosophy and its native compilation with GraalVM, Quarkus optimizes Java for containers with low memory usage and fast startup times.\n\n\nQuarkus achieves this in the following ways:\n\n\n\n\nFirst Class Support for GraalVM\n\n\nBuild Time Metadata Processing: As much processing as possible is\ndone at build time, so your application will only contain the classes\nthat are actually needed at runtime. This results in less memory usage,\nand also faster startup time, as all metadata processing has already been\ndone.\n\n\nReduction in Reflection Usage: Quarkus tries to avoid reflection as much as possible in order to reduce startup time and memory usage.\n\n\nNative Image Pre Boot: When running in a native image, Quarkus\npre-boots as much of the framework as possible during the native image\nbuild process. This means that the resulting native image has already\nrun most of the startup code and serialized the result into the\nexecutable, resulting in an even faster startup-time.\n\n\n\n\nThis gives Quarkus the potential for a great platform for serverless cloud and Kubernetes environments. For more information about Quarkus and its support for devonfw please refer to the Quarkus introduction guide.\n\n\n\nSpring Native\n\n\n\nThe current version of Spring Native 0.10.5 is designed to be used with Spring Boot 2.5.6\n\n\n\n\nLike Quarkus, Spring Native provides support for compiling Spring applications to native executables using the GraalVM native-image compiler deisgned to be packaged in lightweight containers.\n\n\nSpring Native is composed of the following modules:\n\n\n\n\nspring-native: runtime dependency required for running Spring Native, provides also Native hints API.\n\n\nspring-native-configuration: configuration hints for Spring classes used by Spring AOT plugins, including various Spring Boot auto-configurations.\n\n\nspring-native-docs: reference guide, in asciidoc format.\n\n\nspring-native-tools: tools used for reviewing image building configuration and output.\n\n\nspring-aot: AOT transformation infrastructure common to Maven and Gradle plugins.\n\n\nspring-aot-test: Test-specific AOT transformation infrastructure.\n\n\nspring-aot-gradle-plugin: Gradle plugin that invokes AOT transformations.\n\n\nspring-aot-maven-plugin: Maven plugin that invokes AOT transformations.\n\n\nsamples: contains various samples that demonstrate features usage and are used as integration tests.\n\n\n\n\n\nNative compilation with GraalVM\n\nQuarkus and Spring Native both use GraalVM for native compilation. Using a native image provides some key advantages, such as instant startup, instant peak performance, and reduced memory consumption. However, there are also some drawbacks: Creating a native image is a heavy process that is slower than a regular application. A native image also has fewer runtime optimizations after its warmup. Furthermore, it is less mature than the JVM and comes with some different behaviors.\n\n\nKey characteristics:\n\n\n\n\nStatic analysis of the application from the main entry point is\nperformed at build time.\n\n\nUnused parts are removed at build time.\n\n\nConfiguration required for reflection, resources, and dynamic proxies.\n\n\nClasspath is fixed at build time.\n\n\nNo class lazy loading: everything shipped in the executables will be loaded in memory on startup.\n\n\nSome code will run at build time.\n\n\n\n\nThere are limitations around some aspects of Java applications that are not fully supported\n\n\n\nBuild time and start time for apps\n\n\n\n\n\n\n\n\nFramework\nbuild time\nstart time\n\n\n\n\nSpring Native\n19.615s\n2.913s\n\n\nQuarkus Native executable\n52.818s\n0.802s\n\n\n\n\n\nMemory footprints\n\n\n\n\n\n\n\nFramework\nmemory footprint\n\n\n\n\nSpring Native\n109 MB\n\n\nQuarkus Native executable\n75 MB\n\n\n\n\n\nConsidering devonfw best practices\n\nAs of now, devonfw actively supports Spring but not Spring Native.\nAlthough Quarkus has been released to a stable release in early 2021, it has been already used in multiple big projects successfully showing its potential to implement cloud native services with low resource consumption matching the needs of scalability and resilience in cloud native environments.\nWith major stakeholders behind the open source community like Red Hat, its development and growth from its kickoff to the current state is very impressive and really shows the market needs and focus.\nAnother big advantage of Quarkus is that it started on a green field and therefore did not need to circumvent main pillars of the spring framework like reflection, being able to take clean and up-to-date design decisions not needing to cope with legacy issues.\nNonetheless, there is a experimental support also for some spring libraries already available in Quarkus, which make switching from spring to Quarkus much more easier if needed.\nWe also provide a guide\nfor Spring developers who want to adopt or try Quarkus for their\n(next) projects as it really has some gamechanging advantages over\nSpring.\n\n\n\nGeneral recommendations and conclusion\n\nQuarkus and Spring Native both have their own use cases. Under the consideration of the limitations of GraalVM to be used for native images built by Quarkus and Spring Native, there is a strong recommendation towards Quarkus from devonfw.\nOne essential differentiation has to be made on the decision for native or against native applications - the foreseen performance optimization of the JIT compiler of the JVM, which is not available anymore in a native image deployment.\nFor sure, both component frameworks will also run on a JVM getting advantage again from JIT compilation, but depending on the overall landscape then, it is recommended to stay with the knowledge of the available teams, e.g. continue making use of devon4j based on spring or even if already in that state also here make use of Quarkus on JVM.\n\n\n\n\n\nModern project structure\n\nWith trends such as cloud, microservices, lean, and agile, we decided for a more modern project structure that fits better to recent market trends.\nWhen starting new projects with devonfw, and especially in the context of cloud-native development, we strongly recommend this modern approach over the classic structure.\n\n\nModules\n\nDue to trends such as microservices, we are building smaller apps compared to moduliths.\nFor simplicity, we therefore do not split our app into different modules and keep everything top-level and easy.\n\n\nIn addition to java and resources, we also add helm for helm templates and docker for docker scripts (e.g. Dockerfile) in src/main:\n\n\n\n\n\n\n\n\nDeployment\n\nFor modern projects, we strongly recommend that your build process generates the final deliverable as an OCI compliant container.\nFurther, to go fully cloud-native, you should build your app as a native image via GraalVM AOT compiler.\nTherefore, we recommed to use quarkus as your main framework.\nIn case you want to go with spring, you may consider using spring-native.\n\n\n\nLayers\n\nThe package structure of your code inside src/main/java (and src/test/java) of your app is described in our coding conventions in the sections packages.\nFor the modern project structure, the layers are defined by the following table:\n\n\n\n\n\n\n\n\n\nLayer\n«layer»\nDescription\n\n\n\n\nservice\nservice\nThe service layer exposing functionality via its remote API. Typical protocol is REST. May also be any other protocol you are using such as gRPC.\n\n\ndomain\ndomain\nThe domain with the data-model and DB access. Use sub-package (in «detail») repository for repository and dao for DAOs. Also we recommend to put entities in model sub-package.\n\n\nlogic\nlogic\nThe logic layer with the functionallity providing the business value.\n\n\ncommon\ncommon\ncross-cutting code not assigned to a technical layer.\n\n\n\n\n\nArchitecture Mapping\n\nIn order to help you to map the architecture, packaging, layering, etc. to the code and see where different code elements should be placed,\nwe provide this architecture mapping:\n\n\n\n\n\n\n\n\n\n\nDomain Layer\n\nThe domain layer is responsible for the data-model and mapping it to a database.\nThe most common approach is to use a Relational Database Management System (RDMS). In such a case, we strongly recommend to follow our JPA Guide. Some NoSQL databases are supported by spring-data, so you can consider the repository guide.\n\n\nNote: The domain layer is the replacement for the data-access layer in the modern project structure.\n\n\n\n\nGuides\n\n\nGetting started with Quarkus for Spring developers\n\nAs a Spring developer, you have heard more and more about Quarkus: its pros and cons, its fast growth etc. So, you decided to adopt/try Quarkus for your (next) project(s) and are wondering where to go next and what you need to pay attention to when moving from Spring to Quarkus.\n\n\nThis guide tries to address this exact concern. In the following, we will present you some main points you should be aware of when starting to develop with Quarkus, along with some useful sources.\n\n\n\n\nQuarkus is a fairly new Java toolkit. Thus, it is very well documented. It also provides a set of well-written technical guides that are a good starting point to get in touch and make the first steps with Quarkus. See here. It is an Open Source project licensed under the Apache License version 2.0. The source code is hosted in GitHub. If you have any questions or concerns, don’t hesitate to reach out to the Quarkus community.\n\n\nSame as Spring Initializr, you can go to code.quarkus.io to create a new application. Also, check out our Template Quarkus Guide to see our recommendations on certain topics.\n\n\nIn Spring stack, we recommend structuring your application into multiple modules, known as our classic structure. Moving to Quarkus and the world of cloud-native microservices, where we build smaller applications compared to monoliths, we recommend keeping everything top-level and simple. Therefore, we propose the modern structure as a better fit.\n\n\nQuarkus focuses not only on delivering top features, but also on the developer experience. The Quarkus’s Live Coding feature automatically detects changes made to Java files, application configuration, static resources, or even classpath dependency changes and recompiles and redeploys the changes. As that, it solves the problem of traditional Java development workflow, hence improves productivity.\n\n\n\n\n\n\nYou can use this feature out of the box without any extra setup by running:\n\n\n\n\n\n\n\nAnother highlight feature to speed up developing is the Quarkus’s Dev Mode with Dev Services, which can automatically provision unconfigured services in development and test mode. This means that if you include an extension and don’t configure it, Quarkus will automatically start the relevant service and wire up your application to use it, therefore saving you a lot of time setting up those services manually. In production mode, where the real configuration is provided, Dev Services will be disabled automatically.\n\n\nAdditionally, you can access the Dev UI at \\q\\dev in Dev Mode to browse endpoints offered by various extensions, conceptually similar to what a Spring Boot actuator might provide.\n\n\n\nQuarkus is made of a small core on which hundreds of extensions rely. In fact, the power of Quarkus is its extension mechanism. Think of these extensions as your project dependencies. You can add it per dependency manager such as maven or gradle.\n\n\n\n\n\n\nLike Spring Boot, Quarkus also has a vast ecosystem of extensions with commonly-used technologies.\n\n\nTable 32. Example of common Quarkus extensions and the Spring Boot Starters with similar functionality (book: Quarkus for Spring Developer)\n\n\n\n\n\n\nQuarkus extension\nSpring Boot Starter\n\n\n\n\nquarkus-resteasy-jackson\nspring-boot-starter-web\nspring-boot-starter-webflux\n\n\nquarkus-resteasy-reactive-jackson\nspring-boot-starter-web\nspring-boot-starter-webflux\n\n\nquarkus-hibernate-orm-panache\nspring-boot-starter-data-jpa\n\n\nquarkus-hibernate-orm-rest-datapanache\nspring-boot-starter-data-rest\n\n\nquarkus-hibernate-reactive-panache\nspring-boot-starter-data-r2dbc\n\n\nquarkus-mongodb-panache\nspring-boot-starter-data-mongodb\nspring-boot-starter-data-mongodb-reactive\n\n\nquarkus-hibernate-validator\nspring-boot-starter-validation\n\n\nquarkus-qpid-jms\nspring-boot-starter-activemq\n\n\nquarkus-artemis-jms\nspring-boot-starter-artemis\n\n\nquarkus-cache\nspring-boot-starter-cache\n\n\nquarkus-redis-client\nspring-boot-starter-data-redis\nspring-boot-starter-data-redis-reactive\n\n\nquarkus-mailer\nspring-boot-starter-mail\n\n\nquarkus-quartz\nspring-boot-starter-quartz\n\n\nquarkus-oidc\nspring-boot-starter-oauth2-resource-server\n\n\nquarkus-oidc-client\nspring-boot-starter-oauth2-client\n\n\nquarkus-smallrye-jwt\nspring-boot-starter-security\n\n\n\n\nA full list of all Quarkus extensions can be found here. Furthermore, you can check out the community extensions hosted by Quarkiverse Hub. Quarkus has some extensions for Spring API as well, which is helpful when migrating from Spring to Quarkus.\n\n\n\n\nQuarkus Extension for Spring Dependency Injection\n\n\nQuarkus Extension for Spring Web\n\n\nQuarkus Extension for Spring Data JPA\n\n\nQuarkus Extension for Spring Security\n\n\nQuarkus Extension for Spring Boot Properties\n\n\nQuarkus Extension for Spring Cache\n\n\nQuarkus Extension for Spring Cloud Config Client\n\n\nQuarkus Extension for Spring Data REST\n\n\nQuarkus Extension for Spring Scheduled\n\n\n\n\nBesides extensions, which are officially maintained by Quarkus team, Quarkus allows adding external libraries too. While extensions can be integrated seamlessly into Quarkus, as they can be processed at build time and be built in native mode with GraalVM, external dependencies might not work out of the box with native compilation. If that is the case, you have to recompile them with the right GraalVM configuration to make them work.\n\n\n\nQuarkus' design accounted for native compilation by default. A Quarkus native executable starts much faster and utilizes far less memory than a traditional JVM (see our performace comparision between Spring and Quarkus). To get familiar with building native executable, configuring and running it, please check out our Native Image Guide. Be sure to test your code in both JVM and native mode.\n\n\nBoth Quarkus and Spring include testing frameworks based on JUnit and Mockito. Thus, by design, Quarkus enables test-driven development by detecting affected tests as changes are made and automatically reruns them in background. As that, it gives developer instant feedback, hence improves productivity. To use continuous testing, execute the following command:\n\n\n\n\n\n\n\nFor the sake of performance optimization, Quarkus avoids reflection as much as possible, favoring static class binding instead. When building a native executable, it analyzes the call tree and removes all the classes/methods/fields that are not used directly. As a consequence, the elements used via reflection are not part of the call tree so they are dead code eliminated (if not called directly in other cases).\n\nA common example is the JSON library, which typically use reflection to serialize the objects to JSON. If you use them out of the box, you might encounter some errors in native mode. So, be sure to register the elements for reflection explicitly. A How-to is provided by Quarkus Registering For Reflection with practical program snippets.\n\n\n\n\n\nA very good read on the topic is the e-book Quarkus for Spring Developers by Red Hat. Another good source for direct hands-on coding tutorial is Katacoda Quarkus for Spring Boot Developers\n\n\n\n\nConfiguration\n\nQuarkus provides a comprehensive guide on configuration here.\n\n\nExternal Application Configuration\n\nDatabase Configuration\n\nIn Quarkus, Hibernate is provided by the quarkus-hibernate-orm extension. Ensure the extension is added to your pom.xml as follows:\n\n\n\n\n\n\n\nAdditionally, you have to add the respective JDBC driver extension to your pom.xml. There are different drivers for different database types. See Quarkus Hibernate guide.\n\n\n\nDatabase System and Access\n\nYou need to configure which database type you want to use, as well as the location and credentials to access it. The defaults are configured in application.properties. The file should therefore contain the properties as in the given example:\n\n\n\n\n\n\n\n\nDatabase Logging\n\nAdd the following properties to application.properties to enable logging of database queries for debugging purposes.\n\n\n\n\n\n\n\n\n\nSecrets and environment specific configurations\n\nEnvironment variables\n\nThere are also some libraries to make Jasypt work with Quarkus, such as Camel Quarkus Jasypt. Unfortunately, this feature only works in JVM mode and not in native mode.\n\n\nQuarkus supports many credential providers with official extensions, such as HashiCorp Vault.\n\n\n\n\n\n\n\nQuarkus reads configuration values from several locations, ordered by a certain priority. An overview of these can be found at the official  Quarkus config guide.\n\n\nEnvironment variables have a higher ordinal number and are therefore higher prioritized than e.g. the application.properties file.\nSo instead of storing secrets in plain text in the configuration files, it is better to use environment variables for critical values to configure the application.\n\n\nEnvironment variables also have the advantage that they can be easily integrated into a containerized environment.\nWhen using Kubernetes, the secrets can be stored as Kubernetes secret and then passed to the containers as an environment variable.\n\n\n\nCustom config sources\n\nQuarkus provides the possability to add custom config sources, which can be used to retrieve configuration values from custom locations.\nFor a description of this feature, see the corresponding Quarkus guide.\n\n\nConfig interceptors\n\nQuarkus also allows with the concept of interceptors to hook into the resolution of configuration values. This can be useful when configuration values are encrypted or need to be extracted.\nTo do this, you have to implement a ConfigSourceInterceptor.\n\n\n\n\n\n\n\nTo use the Interceptor, you must register it. To do this, create a file  io.smallrye.config.ConfigSourceInterceptor in the folder src/main/resources/META-INF/services and register the interceptor register the interceptor by writing the fully qualified class name to this file.\n\n\n\n\nCredential encryption\n\nAs for Spring, there are also some libraries that let Jasypt work with Quarkus such as Camel Quarkus Jasypt. Unfortunately, this feature only works in JVM mode and not in native mode, so it is not a suitable approach.\n\n\nIf you want to store usernames or passwords in encrypted form or retrieve them from a custom store, you can use a custom CredentialsProvider for this purpose.\nConsider the use case where you want to store your database credentials in encrypted form rather than in plain text. Then you can implement a credentials provider as follows:\n\n\n\n\n\n\n\nIn the application.properties file you need to set quarkus.datasource.credentials-provider=custom.\nFor more information about the credentials provider, see the official Quarkus guide.\n\n\n\nHashiCorp Vault\n\nFor centralized management of secrets and other critical configuration values, you can use HashiCorp Vault as external management tool.\n\n\nFor detailed instructions on how to integrate Vault into your Quarkus application, see the official Quarkus guide.\n\n\n\n\n\n\nQuarkus template\n\nQuarkus Code Generator is provides many alternative technologies and libraries that can be integrated into a project. Detailed guides on multiple topics can be found here.\n\n\nDue to the large selection, getting started can be difficult for developers.\nIn this guide we aim to provide a general suggestion on basic frameworks, libraries, and technologies to make it easy for developers to begin with.\n\n\nWith that said, please take this as a recommendation and not as a compulsion. Depending on your project requirements, you might have to use another stack compared to what is listed below.\n\n\nIf you are new to Quarkus, consider checking out their getting started guide to get an overview of how to create, run, test, as well as package a Quarkus application. Another recommended source to get started is the Katacoda tutorials.\n\n\nBasic templates\n\n\n\nsimple REST API (go to code.quarkus.io)\n\n\nsimple REST API with monitoring (go to code.quarkus.io)\n\n\n\n\nTable 33. Topic-based suggested implementation\n\n\n\n\n\n\n\n\nTopic\nDetail\nSuggested implementation\nNote\n\n\n\n\nruntime\nservlet-container\nUndertow\n\n\n\ncomponent management\ndependency injection\nArC\nArC is based on JSR 365. It also provides interceptors that can be used to implement the same functionality as AOP provides\n\n\nconfiguration\n\nSmallRye Config\nSmallRye Config is an implementation of Eclipse MicroProfile Config. It also supports YAML configuration files\n\n\npersistence\nOR-mapper\nHibernate ORM, Spring Data JPA\nHibernate ORM is the de facto standard JPA implementation and works perfectly in Quarkus. Quarkus also provides a compatibility layer for Spring Data JPA repositories in the form of the spring-data-jpa extension.\n\n\nbatch\n\n\nQuarkus JBeret Extension is a non-official extension, which is hosted in the Quarkiverse Hub. It is an implementation of JSR 352.\n\n\nservice\nREST services\nRESTEasy\nRESTEasy is an portable implementation of the new JCP specification JAX-RS JSR-311. It can be documented via Swagger OpenAPI.\n\n\nasync messaging\nSmallRye Reactive Messaging, Vert.x EventBus\nSmallRye Reactive Messaging is an implementation of the Eclipse MicroProfile Reactive Messaging specification 1.0. You can also utilize SmallRye Reactive Messaging in your Quarkus application to interact with Apache Kafka.\n\n\nmarshalling\nRESTEasy Jackson, RESTEasy JSON-B, RESTEasy JAXB, RESTEasy Multipart\n\n\n\ncloud\nkubernetes\nKubernetes\n\n\n\ndeployment\nMinikube, k3d\nMinikube is quite popular when a Kubernetes cluster is needed for development purposes. Quarkus supports this with the quarkus-minikube extension.\n\n\nlogging\nframework\nJBoss Log Manager and the JBoss Logging facade\nInternally, Quarkus uses JBoss Log Manager and the JBoss Logging facade. Logs from other supported Logging API (JBoss Logging, SLF4J, Apache Commons Logging) will be merged.\n\n\nvalidation\nframework\nHibernate Validator/Bean Validation (JSR 380)\n\n\n\nsecurity\nauthentication &amp; authorization\nJWT authentication\nQuarkus supports various security mechanisms. Depending on your protocol, identity provider you can choose the necessary extensions such as quarkus-oidc quarkus-smallrye-jwt quarkus-elytron-security-oauth2.\n\n\nmonitoring\nframework\nMicrometer Metrics, SmallRye Metrics\nSmallRye Metrics is an implementation of the MicroProfile Metrics specification. Quarkus also offers various extensions to customize the metrics.\n\n\nhealth\nSmallRye Health\nSmallRye Health is an implementation of the MicroProfile Health specification.\n\n\nfault tolerance\nSmallRye Fault Tolerance\nSmallRye Fault Tolerance is an implementation of the MicroProfile Fault Tolerance specification.\n\n\n\n\n\n\n\nBuilding a native image\n\nQuarkus provides the ability to create a native executable of the application called native image.\nUnlike other Java based deployments, a native image will only run on the architecture and operating system it is compiled for.\nAlso, no JVM is needed to run the native-image.\nThis improves the startup time, performance, and efficiency.\nA distribution of GraalVM is needed.\nYou can find the differences between the available distributions here.\n\n\nTo build your quarkus app as a native-image, you have two options that are described in the following sections.\n\n\nBuild a native executable with GraalVM\n\nTo build a Quarkus application, you can install GraalVM locally on your machine, as described below.\nTherefore, read the basic Quarkus application chapter, or clone the example project provided by devonfw.\nFollow this chapter from the Quarkus Guide for building a native executable.\n\n\nInstalling GraalVM\n\nA native image can be created locally or through a container environment.\nTo create a native image locally, an installed and configured version of GraalVM is needed. You can follow the installation guide from Quarkus or the guide provided by GraalVM for this.\n\n\n\n\nBuild a native executable with GraalVM through container environment\n\nIn order to make the build of native images more portable, you can also use your container environment and run the GraalVM inside a container (typically Docker).\nYou can simply install Docker with your devonfw-ide distribution, just follow this description Docker with devonfw-ide.\nFollow this chapter to build a native Linux image through container runtime.\n\n\n\nConfiguring the native executable\n\nA list of all configuration properties for a native image can be found here.\n\n\n\n\n\nBean mapping with Quarkus\n\nThis guide will show bean-mapping, in particular for a Quarkus application. We recommend using MapStruct with a Quarkus application because the other bean-mapper frameworks use Java reflections. They are not supported in GraalVm right now and cause problems when building native applications. MapStruct is a code generator that greatly simplifies the implementation of mappings between Java bean types based on a convention over configuration approach. The mapping code will be generated at compile-time and uses plain method invocations and is thus fast, type-safe, and easy to understand. MapStruct has to be configured to not use Java reflections, which will be shown in this guide.\n\n\nYou can find the official\nMapStruct reference guide and a general introduction to MapStruct from Baeldung.\n\n\nMapStruct Dependency\n\nTo get access to MapStruct, we have to add the dependency to our POM.xml:\n\n\n\n\n\n\n\nMapStruct provides an annotation processor that also has to be added to the POM.xml\n\n\n\n\n\n\n\nMapStruct takes advantage of generated getters, setters, and constructors from the Lombok library, follow this Lombok with Mapstruct guide to get Lombok with Mapstruct working.\n\n\n\nMapStruct Configuration\n\nWe already discussed the benefits of dependency injection. MapStruct supports CDI with EJB, spring, and jsr330. The default retrieving method for a mapper is a factory that uses reflections, which should be avoided. The component model should be set to CDI, as this will allow us to easily inject the generated mapper implementation. The component model can be configured in multiple ways.\n\n\nSimple Configuration\n\nAdd the attribute componentModel to the @Mapper annotation in the mapper interface.\n\n\n\n\n\n\n\n\nMapperConfig Configuration\n\nCreate a shared configuration that can be used for multiple mappers. Implement an interface and use the annotation @MapperConfig for the class. You can define all configurations in this interface and pass the generated MapperConfig.class with the config attribute to the mapper. The MapperConfig also defines the InjectionStrategy and MappingInheritaceStrategy, both of which will be explained later.\nA list of all configurations can be found here.\n\n\n\n\n\n\n\n\n\n\n\n\nAny attributes not given via @Mapper will be inherited from the shared configuration MapperConfig.class.\n\n\n\nConfiguration via annotation processor options\n\nThe MapStruct code generator can be configured using annotation processor options.\nYou can pass the options to the compiler while invoking javac directly, or add the parameters to the maven configuration in the POM.xml\n\n\nWe also use the constructor injection strategy to avoid field injections and potential reflections. This will also simplify our tests.\n\n\nThe option to pass the parameter to the annotation processor in the POM.xml is used and can be inspected in our quarkus reference project.\n\n\nA list of all annotation processor options can be found here.\n\n\n\n\nBasic Bean-Mapper Usage\n\nTo use the mapper, we have to implement the mapper interface and the function prototypes with a @Mapper annotation.\n\n\n\n\n\n\n\nThe MapStruct annotation processor will generate the implementation for us under /target/generated-sources/, we just need to tell it that we would like to have a method that accepts a ProductEntity entity and returns a new ProductDto DTO.\n\n\nThe generated mapper implementation will be marked with the @ApplicationScoped annotation and can thus be injected into fields, constructor arguments, etc. using the @Inject annotation:\n\n\n\n\n\n\n\nThat is the basic usage of a Mapstruct mapper. In the next chapter, we’ll go into a bit more detail and show some more configurations.\n\n\n\nAdvanced Bean-Mapper Usage\n\nLet´s assume that our Product entity and the ProductDto have some differently named properties that should be mapped. Add a mapping annotation to map the property type from Product to kind from ProductDto. We define the source name of the property and the target name.\n\n\n\n\n\n\n\nFor bi-directional mappings, we can indicate that a method shall inherit the inverse configuration of the corresponding method with the @InheritInverseConfiguration. You can omit the name parameter if the result type of method A is the same as the\nsingle-source type of method B and if the single-source type of A is the same as the result type of B. If multiple apply, the attribute name is needed. Specific mappings from the inverse method can (optionally) be overridden, ignored, or set to constants or expressions.\n\n\nThe mappingInheritanceStrategy can be defined as showed in MapStruct Configuration. The existing options can be found here.\n\n\nA mapped attribute does not always have the same type in the source and target objects. For instance, an attribute may be of type int in the source bean but of type Long in the target bean.\n\n\nAnother example are references to other objects which should be mapped to the corresponding types in the target model. E.g. the class ShoppingCart might have a property content of the type Product which needs to be converted into a ProductDto object when mapping a ShoppingCart object to ShoppingCartDto. For these cases, it’s useful to understand how Mapstruct converts the data types and the object references.\n\n\nAlso, the Chapter for nested bean mappings will help to configure MapStruct to map arbitrarily deep object graphs.\n\n\nYou can study running MapStruct implementation examples given by MapStruct or in our Quarkus reference project\n\n\n\n\n\n\n\n"}